<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport"
		content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
	<title>Go+ Builder</title>
	<style>
		*:focus {
			outline: none;
			background-color: black;
		}

		#canvas,
		#gameCanvas {
			display: block;
			margin: 0;
			color: white;
		}
	</style>
</head>

<body>
	<div id="tabs">
		<div id="tab-loader">
		</div>
		<div id="tab-editor" style="display: none;">
		</div>
		<div id="tab-game" style="display: none;">
			<canvas id="game-canvas" tabindex="2">
			</canvas>
		</div>
		<div id="tab-status" style="display: none;">
			<canvas id="editor-canvas" tabindex="1">
			</canvas>
		</div>
	</div>
	<script src="godot.editor.js"></script>
	<script>
		const tabs = [
			document.getElementById('tab-loader'),
			document.getElementById('tab-editor'),
			document.getElementById('tab-game'),
		];
		function showTab(name) {
			tabs.forEach(function (elem) {
				if (elem.id === `tab-${name}`) {
					elem.style.display = 'block';
					if (name === 'editor' || name === 'game') {
						const canvas = document.getElementById(`${name}-canvas`);
						canvas.focus();
					}
				} else {
					elem.style.display = 'none';
				}
			});
		}

		function clearPersistence(targetPath) {
			const req = indexedDB.deleteDatabase(targetPath);
			req.onerror = function (err) {
				alert('Error deleting local files. Please retry after reloading the page.');
			};
			console.log("clear persistence cache", targetPath)
		}

		window.addEventListener('load', () => {
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('service.worker.js').then(function (reg) {
					if (reg.waiting) {
						notifyUpdate(reg.waiting);
					}
					reg.addEventListener('updatefound', function () {
						const update = reg.installing;
						update.addEventListener('statechange', function () {
							if (update.state === 'installed') {
								// It's a new install, claim and perform aggressive caching.
								if (!reg.active) {
									update.postMessage('claim');
								} else {
									notifyUpdate(update);
								}
							}
						});
					});
				});
			}

			InstallProject();
		});


		let editor = null;
		let game = null;
		let projectZip = '/game.zip'
		let persistentPath = '/home/web_user'
		let tempZipPath = '/tmp/preload.zip'
		let projectInstallName = "Game"
		let zipData = null;
		const persistentPaths = [persistentPath];

		function GetInstallPath() {
			return persistentPath + "/" + projectInstallName
		}
		let editorCanvas = document.getElementById('editor-canvas');
		let gameCanvas = document.getElementById('game-canvas');
		let exitFunc = null
		let editorConfig = {
			'unloadAfterInit': false,
			'canvas': editorCanvas,
			'canvasResizePolicy': 0,
			'persistentPaths': persistentPaths,
			'onExecute': function (args) {
				console.log("onExecute  ", args)
			},
			'onExit': function () {
				if (exitFunc) {
					exitFunc()
				}
			}
		};
		function checkKeyExists(dbName, storeName, key) {
			return new Promise((resolve, reject) => {
				let request = indexedDB.open(dbName);
				request.onupgradeneeded = function (event) {
					let db = event.target.result;
					if (!db.objectStoreNames.contains(storeName)) {
						db.createObjectStore(storeName); // 创建对象存储
					}
				};

				request.onsuccess = function (event) {
					let db = event.target.result;

					if (!db.objectStoreNames.contains(storeName)) {
						reject(`Object store "${storeName}" not found`);
						db.close();
						return;
					}
					let transaction = db.transaction(storeName, 'readonly');
					let objectStore = transaction.objectStore(storeName);
					let getRequest = objectStore.getKey(key);
					getRequest.onsuccess = function () {
						if (getRequest.result !== undefined) {
							resolve(true);
						} else {
							resolve(false);
						}
					};

					getRequest.onerror = function () {
						reject('Error checking key existence', dbName);
					};

					transaction.oncomplete = function () {
						db.close();
					};
				};

				request.onerror = function (event) {
					reject('Error opening database: ' + dbName + " " + storeName + " " + event.target.error);
				};
			});
		}


		function checkDBExist(dbName, storeName) {
			return new Promise((resolve, reject) => {
				checkKeyExists(dbName, 'FILE_DATA', storeName).then(exists => {
					resolve(exists);
				}).catch(error => {
					console.error(error);
				});
			});
		}

		async function InstallProject() {
			checkDBExist(persistentPath, GetInstallPath()).then( async (dbExists) => {
				console.log(GetInstallPath(), " DBExist result= ", dbExists)
				if (dbExists) {
					RunGame()
				} else {
					clearPersistence(tempZipPath)
					const zipResp = fetch(projectZip)
					zipData = await(await(zipResp)).arrayBuffer()
					console.log("Load data succ", zipData)
					showTab('status');
					editor = new Engine(editorConfig);
					exitFunc = ImportProject
					editor.init('godot.editor').then(function () {
						editor.copyToFS(tempZipPath, zipData);
						const args = ['--project-manager', '--single-window', "--install_project_name", projectInstallName];
						editor.start({ 'args': args, 'persistentDrops': true });
					});
				}
			}).catch(error => {
				console.error("Error checking database existence: ", error);
			});
		}

		function ImportProject() {
			const args = [
				"--path",
				GetInstallPath(),
				"--single-window",
				"--headless",
				"--editor",
				"--quit-after",
				"30"
			]
			console.log("ImportProject ", args)
			exitFunc = RunGame
			editor.init().then(function () {
				editor.start({ 'args': args, 'persistentDrops': false, 'canvas': editorCanvas });
			});
		}



		function RunGame() {
			const args = [
				"--path",
				GetInstallPath(),
				"--editor-pid",
				"0",
				"res://main.tscn"
			]
			const gameConfig = {
				'persistentPaths': persistentPaths,
				'unloadAfterInit': false,
				'canvas': gameCanvas,
				'canvasResizePolicy': 1,
				'onExit': function () {
					game = null;
				},
			};
			console.log("RunGame ", args)
			if (game) {
				console.error('A game is already running. Close it first');
				return;
			}
			showTab('game');
			exitFunc = null
			game = new Engine(gameConfig);
			game.init('godot.editor').then(function () {
				game.start({ 'args': args, 'canvas': gameCanvas }).then(async () => {
					gameCanvas.focus();
					if (zipData == null) {
						const zipResp = fetch(projectZip)
						zipData = await (await (zipResp)).arrayBuffer()
						console.log("load game data ", zipData)
					}
					window.goLoadData(new Uint8Array(zipData))
				});
			});
		}

	</script>
</body>

</html>